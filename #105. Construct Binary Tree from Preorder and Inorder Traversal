class Solution(object):
    def buildTree(self, preorder, inorder):
        """
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        """
        """
        preorder: [root left right]
        inorder:  [left root right]
        """ 
        
        if len(preorder) == 0:
            return None
        
        L = len(preorder)
        
        pre_idx_stack = [(0, L)]
        offset_stack = [0]
        
        hash_inorder = {inorder[i]:i for i in range(L)}
        
        nodes = list(map(TreeNode, preorder))

        while len(pre_idx_stack) > 0:

            pre_min, pre_max = pre_idx_stack.pop()
            n = pre_max - pre_min
            offset = offset_stack.pop()
            in_min, in_max = pre_min + offset, pre_max + offset
            
            tmp_root = nodes[pre_min]
            
            tmp_left = None
            tmp_right = None
            
            if n != 1: 
                
                _preorder = preorder[pre_min : pre_max]
                _inorder = inorder[in_min : in_max]
                
                root_idx = hash_inorder[_preorder[0]]
                     
                if root_idx != in_min :
                    tmp_left = nodes[pre_min + 1]
                    if root_idx != in_min + 1:   
                        pre_idx_stack.append((pre_min + 1, root_idx + 1 - offset))
                        offset_stack.append(in_min - pre_min - 1)
                    
                if root_idx != in_max - 1:
                    tmp_right = nodes[root_idx + 1 - offset]
                    if root_idx != in_max - 2:
                        pre_idx_stack.append((root_idx + 1 - offset, pre_max))
                        offset_stack.append(in_min - pre_min)
            
            tmp_root.left = tmp_left
            tmp_root.right = tmp_right
            
        return nodes[0]  
